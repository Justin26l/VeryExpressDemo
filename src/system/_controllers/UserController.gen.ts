/**
 * Generated by veryExpress@0.5.11 
 * https://github.com/Justin26l/VeryExpress
 */

import * as controllerFactory from "./_ControllerFactory.gen";
import { Router, Request, Response } from 'express';

import { checkSchema, validationResult } from 'express-validator';
import vex from "./../../system/_utils/index.gen";
import MongoQS from 'mongo-ts-querystring';

import { UserModel } from '../_models/UserModel.gen';

class UserController extends controllerFactory._ControllerFactory {
    public router: Router;

    constructor() {
        super();
        this.router = Router();
        this.routes();
    }

    public routes() {
        
        
        this.router.get('/', 
            checkSchema(            {
              _id: {
                in: 'query',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isString: true,
                custom: { options: this.isObjectId }
              },
              authProfiles: {
                in: 'query',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isString: true
              },
              email: {
                in: 'query',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isString: true
              },
              name: {
                in: 'query',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isString: true
              },
              active: {
                in: 'query',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isBoolean: true
              },
              locale: {
                in: 'query',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isString: true
              },
              roles: {
                in: 'query',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isString: true
              },
              profileErrors: {
                in: 'query',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isString: true
              }
            }),
            this.getListUser.bind(this)
        );

        
        this.router.get('/:id', 
            checkSchema(            {
              id: {
                in: 'params',
                optional: false,
                notEmpty: true,
                isString: true,
                custom: { options: this.isObjectId }
              }
            }),
            this.getUser.bind(this)
        );

        
        this.router.post('/', 
            checkSchema(            {
              authProfiles: {
                in: 'body',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isArray: true
              },
              email: {
                in: 'body',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isString: true
              },
              name: { in: 'body', optional: false, notEmpty: true, isString: true },
              active: { in: 'body', optional: false, notEmpty: true, isBoolean: true },
              locale: {
                in: 'body',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isString: true
              },
              roles: {
                in: 'body',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isArray: true
              },
              profileErrors: {
                in: 'body',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isArray: true
              }
            }),
            this.createUser.bind(this)
        );

        
        // putRoute disabled

        
        this.router.patch('/:id', 
            checkSchema(            {
              id: {
                in: 'params',
                optional: false,
                notEmpty: true,
                isString: true,
                custom: { options: this.isObjectId }
              },
              authProfiles: {
                in: 'body',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isArray: true
              },
              email: {
                in: 'body',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isString: true
              },
              name: {
                in: 'body',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isString: true
              },
              active: {
                in: 'body',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isBoolean: true
              },
              locale: {
                in: 'body',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isString: true
              },
              roles: {
                in: 'body',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isArray: true
              },
              profileErrors: {
                in: 'body',
                optional: { options: { values: 'falsy', checkFalsy: true } },
                notEmpty: true,
                isArray: true
              }
            }),
            this.updateUser.bind(this)
        );

        
        // deleteRoute disabled

    };

    public async getUser(req: Request, res: Response): Promise<Response> {
        try {
            const validationError = validationResult(req);
            if ( ! validationError.isEmpty() ) {
                return vex.response.send(res, 400, {
                    code: vex.response.code.err_validation, 
                    result: validationError.array()
                });
            };

            const result = await UserModel.findById(req.params.id);

            if (!result) {
                return vex.response.send(res, 404);
            }
            else {
                return vex.response.send(res, 200, { result });
            };
        } catch (err:any) {
            return vex.response.send(res, 500, { message: err.message });
        }
    }

    public async getListUser(req: Request, res: Response): Promise<Response> {
        try {
            const validationError = validationResult(req);
            if ( ! validationError.isEmpty() ) {
                return vex.response.send(res, 400, {
                    code: vex.response.code.err_validation, 
                    result: validationError.array()
                });
            };
            
            const searchFilter = new MongoQS().parse(req.query);
            delete searchFilter._select;
            delete searchFilter._join;
            
            let selectedFields : {[key: string]: number} | undefined = undefined;
            let populateOptions : any | undefined = undefined;

            try { 
                selectedFields = vex.common.parseFieldsSelect(req);
                populateOptions = vex.common.parseCollectionJoin(req, {});
            } 
            catch (err:any) { 
                return vex.response.send(res, 400, {
                    code: vex.response.code.err_validation, 
                    result: err.message
                });
            };

            const result = await UserModel.find(searchFilter, selectedFields).populate(populateOptions);
            return vex.response.send(res, 200, { result });
        } catch (err:any) {
            return vex.response.send(res, 500, { result: err.message });
        }
    }

    public async createUser(req: Request, res: Response): Promise<Response> {
        try {
            const validationError = validationResult(req);
            if ( ! validationError.isEmpty() ) {
                return vex.response.send(res, 400, {
                    code: vex.response.code.err_validation, 
                    result: validationError.array()
                });
            };
            if (req.body._id) {
                delete req.body._id;
            };
            
            const result = await UserModel.create(req.body);
            if (!result) {
                return vex.response.send(res, 400, {
                    code: vex.response.code.err_create
                });
            }
            else {
                return vex.response.send(res, 201, {result});
            };
        } catch (err:any) {
            return vex.response.send(res, 500, { message: err.message });
        };
    };

    public async updateUser(req: Request, res: Response): Promise<Response> {
        try {
            const validationError = validationResult(req);
            if ( ! validationError.isEmpty() ) {
                return vex.response.send(res, 400, {
                    code: vex.response.code.err_validation, 
                    result: validationError.array()
                });
            };
            if (req.body._id) {
                delete req.body._id;
            };

            const result = await UserModel.findByIdAndUpdate(req.params.id, req.body, { new: true });
            if (!result) {
                return vex.response.send(res, 404, {
                    code: vex.response.code.err_update
                });
            }
            else {
                return vex.response.send(res, 200, { result });
            };
        } catch (err:any) {
            return vex.response.send(res, 500, { message: err.message });
        }
    }

    public async replaceUser(req: Request, res: Response): Promise<Response> {
        try {
            const validationError = validationResult(req);
            if ( ! validationError.isEmpty() ) {
                return vex.response.send(res, 400, {
                    code: vex.response.code.err_validation, 
                    result: validationError.array()
                });
            };
            if (req.body._id) {
                delete req.body._id;
            };

            const result = await UserModel.replaceOne({_id: req.params.id}, req.body);
            if (!result) {
                return vex.response.send(res, 404, { 
                    code: vex.response.code.err_update
                });
            }
            else {
                return vex.response.send(res, 200, { result });
            };
        } catch (err:any) {
            return vex.response.send(res, 500, { message: err.message });
        }
    }

    public async deleteUser(req: Request, res: Response): Promise<Response> {
        try {
            const validationError = validationResult(req);
            if ( ! validationError.isEmpty() ) {
                return vex.response.send(res, 400, {
                    code: vex.response.code.err_validation, 
                    result: validationError.array()
                });
            };

            const result = await UserModel.findByIdAndDelete(req.params.id);
            if (!result) {
                return vex.response.send(res, 404, {
                    code: vex.response.code.err_delete
                });
            }
            else {
                return vex.response.send(res, 204, { result });
            };
        } catch (err:any) {
            return vex.response.send(res, 500, { message: err.message });
        }
    }
}

export default new UserController().router;
